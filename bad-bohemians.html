---
layout: page
title: Bad Bohemians
description: Solo Project
---

<article class="px-1">
  <div class="text-panel" style="color:white;">
    <h3 style="margin-top:0rem;color:white"><strong>Taking a stab at the procedural whodunnit...</strong></h3>
    <p><b>Key Achievements</b> Designed a generator to set (and solve) uniquely-determined logic puzzles, themed as murder mysteries. Optimised its constraint solver within an inch of its life, using SIMD and other low-level CPU tricks. Added grammars, plus a custom lightweight markup, to write the puzzles' procedural text.</p>
    <strong>Made With </strong></em>Godot, C++.
  </div>

  <p></p>
  <p><i>Bad Bohemians</i> is a logic puzzler, in the vein of <i>Return of the Obra Dinn</i> and the <i>Golden Idol</i> series. What's different here is <i>Bad Bohemians</i>' whodunnits are entirely procedural: each has been generated by the computer, at runtime, without any human oversight. It is, at least in theory, an endlessly replayable murder mystery, in which the plater has to piece together each suspect's identity (their forename, surname, etc.) from their eyewitness accounts of the evening at hand.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-02-23-theres-been-a-murder.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>The Usual Suspects</b> A procedurally-generated line up of characters - and a dead body for good measure.</p>
  </div>
  <!-- <div style="margin-top:2rem;text-align:center"> -->
  <!-- <div style="margin-top:2rem;aspect-ratio:1280/760;text-align:center"> -->
    <!-- FIXME: HTML demo -->
  <!-- </div> -->
  <p>In its current state, <i>Bad Bohemians</i> is still the stereotype of a programmer's game: the art is amateurish, the audio non-existent, but <strong>god</strong> has it been optimised to hell and back. Some of these optimisations, like my use of Streaming SIMD Extensions (SSE) and my abuse of uint64_ts, make Godot particularly angry when trying to export it for web, so <strong><a href="https://commit-to-the-bit.itch.io/bad-bohemians" target="_blank" rel="noreferrer noopener">the demo</a></strong> is Windows-only for now<!--we've had to come to a compromise. While the full, Windows demo generates puzzles dynamically, this HTML version can only showcase a finite set of pre-generated examples-->. Like any stereotypical programmer's game, though, it might still be more impressive to read about than actually play...</p>

  <h2>First Drafts</h2>
  <p>This project's been a long time coming. <i>Bad Bohemians</i> started out back in 2022, when I came up with it<!--While I only started on the current iteration of <i>Bad Bohemians</i> in early 2024, I'd originally come up with the game--> as a way-too-ambitious project for one of my Master's modules. Naturally, this early prototype had some superficial differences (it only ran in a console, for a start!), but the structure of the generator remains the same. Starting with a constraint solver, we generate a bunch of clues, find a subset that lead the solver to the correct answer, then iterate that subset until the puzzle is challenging enough. First time around, that iteration was done with a genetic algorithm; the solver underpinning it a rules-based system based off of "if-then" statements, that in hindsight would've been far better implemented in a functional programming language than it was in C#.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-01-20-bad-bohemians-genetic-algorithm-puzzle.png" alt="Alt. text." style="auto;aspect-ratio:1200/530;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>Text-Based Misadventures</b> An early, text-only puzzle, generated with Bad Bohemians' original genetic algorithm. Back then, the puzzles were framed through the lens of a gossip column, with players matching different rumours to different members of the landed gentry.</p>
  </div>
  <p>The project might have got an A+, but even at the time it had some pretty glaring faults. The solver was slow, the text generation rigid, the genetic algorithm unlikely to produce optimal mutations - indeed, I barely had a metric for what an optimal mutation would actually <i>be</i>. Though I would triaging where I could to meet my deadline, I knew that meaningfully improving these puzzles would take redesigning the entire generator, swapping out its C# for C++, and ekeing out the performance needed for more narrative complexity. <strong>So that's what I did.</strong></p>

  <h2>Getting the Story Straight</h2>
  <p>What makes a puzzle puzzling? What are its key qualities, and how could one describe them in ways a computer could understand? It can't be over- or underdetermined, for a start; a whodunnit needs a single, consistent solution. In an essay on <a href="https://www.taylorfrancis.com/chapters/edit/10.1201/9781315156378-13/puzzles-danny-day"><strong>designing <i>Desktop Dungeons</i>' procedural dungeons</strong></a>, Danny Day frames solvability as a matter of decency. Players need to trust that <i>Bad Bohemians</i> respects their time, and that trust will rightly evaporate if we ever present them incomplete or contradictory information. So, the puzzles must be solvable - but they can't be too solvable. The challenge of a game like <i>Obra Dinn</i> comes from having to cross-reference your sources of information, from uncovering its story piece by bloody piece; no single clue gives too much away. In <i>Bad Bohemians</i>, I've formalised all of these design requirements into not-insubstantial code...
  <p>One of the first steps in fleshing out my prototype into a full demo was refactoring its solver in C++. Conceptually, it now treats the space of possible solutions to a given puzzle as a dictionary of possible character traits, each with an upper and lower bound on how many characters display said trait. In <i>Bad Bohemians</i>' case, these bounds might translate as "No more than two characters are from the Caine family" or "There are no Dukes called Abigail", statements of that nature. Crucially, the construction allows us an easy check for underdeterminedness. Defining the <i>ambiguity</i> of a puzzle as the sum of all the solver's maxima, minus the sum of all minima, we can then clearly see a puzzle has a unique solution if and only if it has zero ambiguity.</p>
  <p>Similarly, consistency can be framed as "not contradicting the bounds". As we propagate information through the solver, our bounds will get tighter and tighter. However, if a minimum gets raised to be higher than its maximum, or vice versa, the solver will terminate early, telling the rest of the generator it's been fed contradictory information and is thus overdetermined.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/posts/2024-07-27-toggling-clues.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>Little Grey Cells</b> A debugging tool for visualising of the solver's grid structure: in each cell, [...]. Individual clues can be toggled on and off, to see [...] and correct any logic errors.</p>
  </div>
  <p>Let's now define another term. Let x be the ambiguity of a solver before any clues have been fed in, and x_n its ambiguity once only our nth clue has. We might then think of x - x_n, the reduction in ambiguity thanks to n alone, as the <i>obviousness</i> of clue n. Moreover, we define the obviousness of a puzzle as the sum of obviousnesses of its clues. This number represents how much information is given to the user prima facia, that doesn't need deduced by cross-referencing clues; to optimise a puzzle is to minimise its obviousness. Indeed, the gold standard of puzzle is one with obviousness strictly less than its initial ambiguity - satisfying the inequality sum(x_n - x) < x means a puzzle encodes, quite literally, more information than the sum of its parts!</p>
  <p>When the generator writes a new clue (more on text generation below), it can be evaluated in terms of these three metrics. After first verifying the clue is consistent, we check if swapping it with any existing clue will reduce the ambiguity of a puzzle, or reduce the obviousness without its ambiguity increasing; if either condition is met, we make the substitution. Perhaps unsurprisingly, this is the bottleneck of the whole generation process. The problem with defining a clue's quality relative to the state of the solver (a solver that contains tens of thousands of bounds that it needs to tighten every time it receives information, I might add), is that actually <i>determining</i> the quality of hundreds of clues involves running that solver over and over and over. It's not ideal. <i>Bad Bohemians</i> can reliably write puzzles for a cast of six characters in somewhere between 30 second to one minute, but it really, really struggles to introduce a seventh. From profiling, though, the solver is running fast enough - it's just running too often. The current set-up is better than the genetic algorithm I was using before, sure, but it still isn't converging on an optimal set of clues as it is taking shots in the dark and eventually getting lucky.</p>

  <h2>Good Grammar</h2>
  <p>It's worth mentioning here that the solver is not a natural language processor. When I talk about it making interferences from the clue, the solver is really just parsing an attached markup that encodes the information of the text in a format it can understand. For example, "Abigail is a Baroness" would be marked up as</p>
  <ul style="list-style: none;">
    <li><i>[forename]:(Abigail):[1],</i></li>
    <li><i>[forename,nobility]:(Abigail,Baroness):[1].</i></li>
  </ul>
  <p>The first term tells the computer there is exactly one Abigail, the second that there is exactly one <i>Baroness</i> Abigail, and so they are one and the same; Abigail is indeed a Baroness. There's a nuance to encoding more complex sentence structures, but the markup is such that for every entry in a bank of clues, a human writer can in theory go through and tag them with the bounds they need to be read by the solver.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-02-23-lord-rest-her.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>You Got Me Monologuing</b> The player's main sources of information are the suspects' firsthand accounts of the murder, but there may also be visual signifiers of, say, a character's gender.</p>
  </div>
  <p>...In theory. In practice, we're not using prewritten clues, we're creating them on the fly. The challenge of text generation therefore bifurcates into generating both human-readable prose, and markup that tells the computer the exact same information - and any discrepancies between the two could render the puzzles unsolvable.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-02-23-lord-rest-her.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>The Sincerest Form Of Flattery</b> Whenever three or so characters are been correctly identified, [...]. It's a neat little game design trick to let the player know they're on the right track, ripped wholesale from <i>Return of the Obra Dinn</i>.</p>
  </div>
  <p>The results are mixed.</p>

    <h2>Loose Ends</h2>
  <p>This is, for all intents and purposes, a successful demo: I've created an game capable of using my own words and my own logic to generate puzzles that nonetheless challenge <i>me</i>. I've packaged it into a GDExtension, for easy porting into future projects. I even found the time to add juice, from the shader textures I wrote for my doodles to the Verlet rope physics I added to the pinboard UI. But that doesn't mean I'm done with it yet.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-02-23-customisation-screen.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>Tying It All Together</b> The game's note-taking interface, styled as a evidence board. The player can [...]. I struggled to balance [...], but in playtests users [...].</p>
  </div>
  <p>First, I'll need more debugging tools. Some of those I can find online - I'm keen to start using <a href="https://github.com/wolfpld/tracy"><strong>tracy</strong></a> for profiling as soon as I've switched to building with CMake instead of scons<sup>1</sup> - but others I'm going to have create myself. The current set up is minimal: I've watermarked each puzzle with its seed, and my debug builds allow me to print answers, but that's about it. [Internal work]. Any truly full release would also need a player-facing hints system, to [...]... but I'm still some ways off from that for now.</p>
  <div style="text-align:center;width:90%;display:block;margin-left:auto;margin-right:auto">
    <img src="assets/img/projects/2025-02-23-customisation-screen.png" alt="Alt. text." style="aspect-ratio:16/9;border-radius:0.5rem;">
    <p style="font-size:80%;padding:0;color:#6d6c6c;"><b>Seeds of Doubt</b> [...]</p>
  </div>
  <p>The other challenge is one of scale. [Text generation]. <i>Bad Bohemians</i> uses a grammar-based approach for its text generation, which, while not entirely unsuccessful, certainly has room for improvement. Grammars are useful for lightweight text generation, but they struggle at encoding more macro constraints, like [...]. What that means is, right now, adding prose to the generator comes with a lot of markup, which is at best a hassle, and at worst a point where poorly-written constraints can confuse the solver.</p>
  <p style="line-height:1.25"><sup><sup>1</sup> Why Godot uses scons to begin with, I have no idea. Being a real CMake amateur back when I first set <i>Bad Bohemians</i> up, I thought it'd make sense to follow the engine's GDExtensions documentation to the letter. <a href="https://vilelasagna.ddns.net/coding/setting-up-your-gdextension-with-cmake-and-qt-creator/"><strong>Jehferson Mello</strong></a> and <a href="https://thatonegamedev.com/cpp/cmake/godot-4-gdextension-for-c-using-cmake/"><strong>Hristo Iliev</strong></a>'s blogs have since shown me the error of my ways, and helped me configure a far superior build system on subsequent projects.</sup></p>

  <h2 style="text-align:right">Many, <em>many</em> more details can be found in my <a href="https://committothebit.github.io/categories/procedural-whodunnits/"><strong>Procedural Whodunnits</strong></a> devlogs. The full demo is available on <strong><a href="https://commit-to-the-bit.itch.io/bad-bohemians" target="_blank" rel="noreferrer noopener">Itch.io</a></strong></h2>
</article>
